"use strict";
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.MavenWorkspace = void 0;
const workspace_1 = require("./workspace");
const version_1 = require("../version");
const versioning_strategy_1 = require("../versioning-strategy");
const dom = require("@xmldom/xmldom");
const xpath = require("xpath");
const path_1 = require("path");
const pom_xml_1 = require("../updaters/java/pom-xml");
const changelog_1 = require("../updaters/changelog");
const pull_request_title_1 = require("../util/pull-request-title");
const pull_request_body_1 = require("../util/pull-request-body");
const branch_name_1 = require("../util/branch-name");
const logger_1 = require("../util/logger");
const JAVA_RELEASE_TYPES = new Set(['java', 'java-bom', 'java-yoshi', 'maven']);
const XPATH_PROJECT_GROUP = '/*[local-name()="project"]/*[local-name()="groupId"]';
const XPATH_PROJECT_ARTIFACT = '/*[local-name()="project"]/*[local-name()="artifactId"]';
const XPATH_PROJECT_VERSION = '/*[local-name()="project"]/*[local-name()="version"]';
const XPATH_PROJECT_DEPENDENCIES = '/*[local-name()="project"]/*[local-name()="dependencies"]/*[local-name()="dependency"]';
class MavenWorkspace extends workspace_1.WorkspacePlugin {
    async fetchPom(path) {
        const content = await this.github.getFileContentsOnBranch(path, this.targetBranch);
        const document = new dom.DOMParser().parseFromString(content.parsedContent);
        const groupNodes = xpath.select(XPATH_PROJECT_GROUP, document);
        if (groupNodes.length === 0) {
            this.logger.warn(`Missing project.groupId in ${path}`);
            return;
        }
        const artifactNodes = xpath.select(XPATH_PROJECT_ARTIFACT, document);
        if (artifactNodes.length === 0) {
            this.logger.warn(`Missing project.artifactId in ${path}`);
            return;
        }
        const versionNodes = xpath.select(XPATH_PROJECT_VERSION, document);
        if (versionNodes.length === 0) {
            this.logger.warn(`Missing project.version in ${path}`);
            return;
        }
        const dependencies = [];
        const testDependencies = [];
        for (const dependencyNode of xpath.select(XPATH_PROJECT_DEPENDENCIES, document)) {
            const parsedNode = (0, pom_xml_1.parseDependencyNode)(dependencyNode);
            if (!parsedNode.version) {
                continue;
            }
            if (parsedNode.scope === 'test') {
                testDependencies.push({
                    groupId: parsedNode.groupId,
                    artifactId: parsedNode.artifactId,
                    version: parsedNode.version,
                });
            }
            else {
                dependencies.push({
                    groupId: parsedNode.groupId,
                    artifactId: parsedNode.artifactId,
                    version: parsedNode.version,
                });
            }
        }
        const groupId = groupNodes[0].firstChild.textContent;
        const artifactId = artifactNodes[0].firstChild.textContent;
        return {
            path,
            groupId,
            artifactId,
            name: `${groupId}:${artifactId}`,
            version: versionNodes[0].firstChild.textContent,
            dependencies,
            testDependencies,
            pomContent: content.parsedContent,
        };
    }
    async buildAllPackages(candidates) {
        const allPackages = [];
        const candidatesByPackage = {};
        // find all pom.xml files and build a dependency graph
        const pomFiles = await this.github.findFilesByFilenameAndRef('pom.xml', this.targetBranch);
        for (const pomFile of pomFiles) {
            const path = (0, path_1.dirname)(pomFile);
            const config = this.repositoryConfig[path];
            if (!config) {
                this.logger.info(`path '${path}' not configured, ignoring '${pomFile}'`);
                continue;
            }
            const mavenArtifact = await this.fetchPom(pomFile);
            if (!mavenArtifact) {
                continue;
            }
            allPackages.push(mavenArtifact);
            const candidate = candidates.find(candidate => candidate.path === path);
            if (candidate) {
                candidatesByPackage[this.packageNameFromPackage(mavenArtifact)] =
                    candidate;
            }
            else {
                this.logger.warn(`found ${pomFile} in path ${path}, but did not find an associated candidate PR`);
            }
        }
        return {
            allPackages,
            candidatesByPackage,
        };
    }
    async buildGraph(allPackages) {
        const artifactsByName = allPackages.reduce((collection, mavenArtifact) => {
            collection[mavenArtifact.name] = mavenArtifact;
            return collection;
        }, {});
        const graph = new Map();
        for (const mavenArtifact of allPackages) {
            const allDeps = [
                ...mavenArtifact.dependencies,
                ...mavenArtifact.testDependencies,
            ];
            const workspaceDeps = allDeps.filter(dep => artifactsByName[packageNameFromGav(dep)]);
            graph.set(mavenArtifact.name, {
                deps: workspaceDeps.map(dep => packageNameFromGav(dep)),
                value: mavenArtifact,
            });
        }
        return graph;
    }
    bumpVersion(artifact) {
        const version = version_1.Version.parse(artifact.version);
        return new versioning_strategy_1.PatchVersionUpdate().bump(version);
    }
    updateCandidate(existingCandidate, artifact, updatedVersions) {
        const version = updatedVersions.get(artifact.name);
        if (!version) {
            throw new Error(`Didn't find updated version for ${artifact.name}`);
        }
        const updater = new pom_xml_1.PomXml(version, updatedVersions);
        const dependencyNotes = getChangelogDepsNotes(artifact, updater, updatedVersions, this.logger);
        existingCandidate.pullRequest.updates =
            existingCandidate.pullRequest.updates.map(update => {
                if (update.path === (0, workspace_1.addPath)(existingCandidate.path, 'pom.xml')) {
                    update.updater = updater;
                }
                else if (update.updater instanceof changelog_1.Changelog) {
                    if (dependencyNotes) {
                        update.updater.changelogEntry =
                            (0, workspace_1.appendDependenciesSectionToChangelog)(update.updater.changelogEntry, dependencyNotes, this.logger);
                    }
                }
                return update;
            });
        // append dependency notes
        if (dependencyNotes) {
            if (existingCandidate.pullRequest.body.releaseData.length > 0) {
                existingCandidate.pullRequest.body.releaseData[0].notes =
                    (0, workspace_1.appendDependenciesSectionToChangelog)(existingCandidate.pullRequest.body.releaseData[0].notes, dependencyNotes, this.logger);
            }
            else {
                existingCandidate.pullRequest.body.releaseData.push({
                    component: artifact.name,
                    version: existingCandidate.pullRequest.version,
                    notes: (0, workspace_1.appendDependenciesSectionToChangelog)('', dependencyNotes, this.logger),
                });
            }
        }
        return existingCandidate;
    }
    newCandidate(artifact, updatedVersions) {
        const version = updatedVersions.get(artifact.name);
        if (!version) {
            throw new Error(`Didn't find updated version for ${artifact.name}`);
        }
        const updater = new pom_xml_1.PomXml(version, updatedVersions);
        const dependencyNotes = getChangelogDepsNotes(artifact, updater, updatedVersions, this.logger);
        const pullRequest = {
            title: pull_request_title_1.PullRequestTitle.ofTargetBranch(this.targetBranch),
            body: new pull_request_body_1.PullRequestBody([
                {
                    component: artifact.name,
                    version,
                    notes: (0, workspace_1.appendDependenciesSectionToChangelog)('', dependencyNotes, this.logger),
                },
            ]),
            updates: [
                {
                    path: (0, workspace_1.addPath)(artifact.path, 'pom.xml'),
                    createIfMissing: false,
                    updater,
                },
                {
                    path: (0, workspace_1.addPath)(artifact.path, 'CHANGELOG.md'),
                    createIfMissing: false,
                    updater: new changelog_1.Changelog({
                        version,
                        changelogEntry: dependencyNotes,
                    }),
                },
            ],
            labels: [],
            headRefName: branch_name_1.BranchName.ofTargetBranch(this.targetBranch).toString(),
            version,
            draft: false,
        };
        return {
            path: artifact.path,
            pullRequest,
            config: {
                releaseType: 'maven',
            },
        };
    }
    inScope(candidate) {
        return JAVA_RELEASE_TYPES.has(candidate.config.releaseType);
    }
    packageNameFromPackage(artifact) {
        return artifact.name;
    }
    pathFromPackage(artifact) {
        return artifact.path;
    }
    postProcessCandidates(candidates, _updatedVersions) {
        // NOP for maven workspaces
        return candidates;
    }
}
exports.MavenWorkspace = MavenWorkspace;
function packageNameFromGav(gav) {
    return `${gav.groupId}:${gav.artifactId}`;
}
function getChangelogDepsNotes(artifact, updater, updatedVersions, logger = logger_1.logger) {
    const document = new dom.DOMParser().parseFromString(artifact.pomContent);
    const dependencyUpdates = updater.dependencyUpdates(document, updatedVersions);
    const depUpdateNotes = [];
    for (const dependencyUpdate of dependencyUpdates) {
        depUpdateNotes.push(`\n    * ${dependencyUpdate.name} bumped to ${dependencyUpdate.version}`);
        logger.info(`bumped ${dependencyUpdate.name} to ${dependencyUpdate.version}`);
    }
    if (depUpdateNotes.length > 0) {
        return `* The following workspace dependencies were updated${depUpdateNotes.join()}`;
    }
    return '';
}
//# sourceMappingURL=maven-workspace.js.map